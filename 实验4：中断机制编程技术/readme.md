# 实验4：中断机制编程技术

## 一. 实验目的
- 掌握 pc 微机的实模式硬件中断系统原理和**中断服务程序设计方法**。
- 掌握操作系统的**系统调用原理**。
- 学习握掌 **C 语言库**的设计方法。

## 二. 实验要求
- 实现对时钟、键盘/鼠标等硬件**中断**的简单**服务处理程序编程**和调试，让你的原型操作系统在运行以前己有的用户程序时，能对异步事件正确捕捉和响应。
- 提供若干简单功能的软中断。
- 实现原型操作系统中的**系统调用框架**，提供若干简单功能的系统调用。
- 为自己的原型操作系统配套一个 **C 程序开发环境**，实现用自建的 C 语言开发简单的输入/输出的用户程序，**展示封装的系统调用**。

## 三. 相关原理

### 中断处理过程
中断处理分三个步骤。(其中一三步需要自己在中断响应程序中实现。第二步由系统自身实现，但需自己修改中断向量表。)
```
中断向量是中断服务程序的入口地址
```
#### 第一步是保护断点的现场。
在这一步有两件事情要做：
- 第一，**将标志寄存器FLAGS压栈，再清除它的IF位和TF位**。清除IF位和TF位是为了避免在中断中响应其他中断，所以如果你在自己的中断中想要响应其他中断的话，则必须先把IF和TF位置"1"，可以使用sti命令。  
- 第二，**将当前的代码段寄存器CS和指令指针寄存器IP压栈**，以保证中断执行完后可以返回当前代码段。

#### 第二步则是执行中断处理程序。
- 处理器拿到中断号后，将中断号乘以4（每个中断在中断向量表中占4字节），得到该**中断入口点在中断向量表中的偏移地址**。  
- 从表中依次取出**中断程序的偏移地址和段地址**，并分别传送到IP和CS，然后，处理器就开始执行中断处理程序了。

#### 第三步是返回到断点接着执行。
- 所有**中断处理程序的最后一条指令必须是中断返回指令```iret```**。 **```iret``` 将导致处理器依次从堆栈中弹出（恢复） IP、 CS和FLAGS的原始内容**，于是转到主程序接着执行。

### 系统调用
(系统调用是指，用户程序调用操作系统提供的一些子功能。用户程序通过执行陷入指令来发起系统调用，将CPU的使用权主动交给内核。)

操作系统除了执行用户的程序，还有义务为用户程序开发提供一些常用的服务。

因为操作系统要提供的服务更多，服务子程序数量太多，但中断向量有限，所以**通过不同的软中断提供不同的操作系统服务是不合适的**。  
因此，实际做法是**专门指定一个中断号对应服务处理程序总入口，然后再将服务程序所有服务用功能号区分，并作为一个参数从用户中传递过来，服务程序再进行分支，进入相应的功能实现子程序。**  即系统调用。

这种方案至少**要求向用户公开一个中断号和参数表，即所谓的系统调用手册**，供用户使用。  
**规定系统调用服务的中断号是21h**。  

如果用户所用的开发语言是汇编语言，可以直接使用软中断```int 21h```调用。如果使用高级语言，则要用库过程封装调用的参数传递和软中断等指令汇编代码。

### 硬中断和软中断
#### 硬中断（外部中断）——由外部（主要是外设[即I/O设备]）的请求引起的中断
- 时钟中断（计时器产生，等间隔执行特定功能）
- I/O中断（I/O控制器产生，通知操作完成或错误条件）
- 硬件故障中断（故障产生，如掉电或内存奇偶校验错误）
#### 软中断（内部中断）——由指令的执行引起的中断
- 中断指令（**软中断int n**、溢出中断into、中断返回iret、单步中断TF=1）
- **系统调用属于软中断**
#### 异常/程序中断（指令执行结果产生，如溢出、除0、非法指令、越界）
- 有些会将软中断和异常分类到一起，称作内中断(或异常)。

## 四. 实验方案

### 程序流程
1. 引导程序加载内核。
2. (内核首先修改中断向量表)，内核作为控制台，通过命令加载用户子程序并跳转
到子程序运行。
3. 用户子程序执行期间响应**硬件中断，软中断以及系统调用**。
4. 从用户子程序返回内核响应中断响应程序，执行中断响应程序。
5. 从中断响应程序返回用户子程序并继续执行。

### 实验内容
#### 1. 设计自己的时钟中断响应程序：(硬中断)
- 在屏幕的右下角沿矩形动态画框，并循环变色。
#### 2. 改写键盘响应中断程序：(硬中断)
- 每当有按键输入的时候，正常获取按键后，在屏幕右下方显示“OUCH”，
- 在时钟中断中将该“OUCH”清空，使得每次按键输入都闪现“OUCH”
#### 3. 为int 34， int 35， int 36， int 37编写中断响应程序：(软中断)
分别在左上角，右上角，左下角，右下角播放逐字符飞入动画显示个人信息。
#### 4. 设计自己的系统调用程序，通过ah的值调用int 21h中断的不同功能：(系统调用)
- ①获取当前时间并显示于右下角 ah = 0
- ②切换背景颜色 ah = 1
- ③切换前景颜色 ah = 2
- ④关机 ah = 3
- ⑤重启 ah = 4
#### 5. 设计一个简单的用户子程序来测试所有的中断与系统调用
- 通过键盘输入测试硬中断：键盘响应中断以及时钟中断。
- 通过执行指令测试软中断(int 34~37)以及系统调用(int 21h)。

#### 建立不同功能的C函数库；封装系统调用
- io函数库：输入输出函数
- string函数库：字符串处理函数
- time函数库：时间函数
- stdlib函数库：杂项函数

### 实现方法
硬中断、软中断和系统调用的实现方法都基本一样。不同在于调用方法：硬中断由硬件请求触发；软中断通过中断指令 ```int n``` 调用；系统调用也通过中断指令 ```int 21h``` 调用，但要通过"ah寄存器"指定功能号。
#### 中断处理实现方法：
- 第一，设计中断响应程序，**中断响应程序开头保存断点环境，结尾恢复环境并返回断点**。而中断响应程序的功能则根据具体需要来设计。
- 第二，设计好中断响应程序之后，要**把中断响应程序的首地址(即中断向量)放到中断向量表中**。 所有中断响应程序都需要把程序首地址放到对应的中断向量表。在发生中断时，处理器会通过中断号自动执行中断响应程序。

### 关键模块
#### 把自设计中断响应程序的地址放到中断向量表中
```x86asm
; kernel.asm
Setaddr:
;判断是否初始化了,已设置就跳转
	cmp byte[cs:is_init],1
	jz start
	inc byte[cs:is_init]
;时钟中断响应地址
	xor ax,ax
	mov es,ax
	mov word[es:20h],int_8				; 设置时钟中断向量的偏移地址
	mov word[es:22h],cs					; 设置时钟中断向量的段地址
;键盘中断响应地址
	mov ax,word[es:24h]
	mov word[cs:pre_int9_addr],ax		; 保存原键盘中断响应程序的偏移地址
	mov ax,word[es:26h]
	mov word[cs:pre_int9_addr+2],ax		; 保存原键盘中断响应程序的段地址
	mov word[es:24h],int_9
	mov word[es:26h],cs
;系统调用中断 int_21h,33号中断
	mov ax,word[es:84h]
	mov word[cs:pre_int21h_addr],ax	
	mov ax,word[es:86h]
	mov word[cs:pre_int21h_addr+2],ax	
	mov word[es:84h],int_21h
	mov word[es:86h],cs
;int 34号中断,22h
	mov word[es:88h],int_34		
	mov word[es:8ah],cs
```

#### 中断响应程序设计
```x86asm
;时钟中断响应程序	
int_8:
	pushf				; 标志寄存器压栈
	pushad				; 将所有的32位通用寄存器压栈
	cli					; 中断标志置0指令 使 IF = 0. (标志寄存器出栈后，中断标志会被恢复，所以不需要退出前使用sti来恢复中断。)
	......
end_:
	popad
	popf
	push ax
	mov al,20h			; AL = EOI
	out 20h,al			; 发送EOI到主8529A
	out 0A0h,al			; 发送EOI到从8529A	
	pop ax
	iret
```
```x86asm
;键盘中断响应程序,int 9
int_9:
;调用旧的9号中断
	pushf						; 
	cli
	call far[cs:pre_int9_addr]	; 原中断的结尾时以中断返回指令iret(将从堆栈返回ip、cs和FLAGS)以；使用call far后，对ip和cs压栈，并以retf返回；因此将压ip和cs，并以iret返回，所以需要自行事先对标志寄存器压栈。
	pushf
	pushad
	......					; 一些输出
	popad
	popf	
	iret
```
```x86asm
;系统调用中断，int_21h，五个功能
;AH 放置功能调用号
;功能一：更新系统时间 disptime       ah = 0
;功能二：改变背景颜色 changebcolor   ah = 1
;功能三：改变字体颜色 changefcolor   ah = 2
;功能四：关机         Shutdown       ah = 3
;功能五：重启		  Restart        ah = 4
int_21h:
	pushf
	pushad
	xor ecx,ecx
	cmp ah,0				; 根据功能号选择不同的分支调用不同的系统调用。
	jz int_21h_0
	......
int_21h_end:
	popad
	popf
	iret
int_21h_0:	
	mov ecx,_Disptime
	call ecx
	jmp int_21h_end
```
```x86asm
; 软中断，int 34
int_34:
	pushf
	pushad
	cli
	xor eax,eax
	mov ax,_drawLfUp
	call eax	
	popad
	popf
	iret
```

#### 测试子程序调用软中断和系统调用
```x86asm
; test.asm
......
int 34			; 调用34号软中断
......
int_21_0:
	mov ah,0	; 功能号为0
	int 21h		; 调用系统调用
......
```

------
## 其他
<!-- 
### 软中断和硬中断
#### 硬中断
- 硬中断是**由外部事件(设备/硬件)引起**的，因此具有随机性；
- 硬中断的中断号是由中断控制器提供的；
- 硬中断是可屏蔽的；
- CPU在中断响应周期检查是否有硬中断。中断响应周期(即CPU在指令执行阶段结束前，要发中断查询信号，以检测是否有某个I/O提出中断请求。)
- 关键是响应外部设备的请求，例如网卡、键盘、时钟、打印机等。
#### 软中断
- 软中断是主动**执行中断指令(包括```int n```)产生**的，是由程序安排好的；
- 软中断的中断号是由指令直接给出的；
- 软中断是不可屏蔽的；
- 关键是程序主动调用发起的，请求服务，例如
	- **系统调用属于软中断**。
- 通常将指令执行中的一些特殊异常也看作软中断，例如算术溢出、除0。
-->

### ret, retf, iret指令的差异：
- ret指令是段内返回指令，只从堆栈返回ip
- retf指令是段间返回指令，从堆栈返回ip和cs
- iret指令是中断返回指令，从堆栈返回ip、cs和FLAGS
```
只由C调用的汇编函数应当用retf返回 (具体见实验报告)
```

### 获取当前时间：
当前的时间存放在CMOS RAM中。
每个时间占一个字节，存储格式是BCD码，高四位放十位数，第四位放个位数。年只存放最后两位，如现在的年份只存储18。
存放单元如下：
```
秒：0   分：2   时：4   日：7   月：8   年：9
```
要读取时间时，先向地址端口70h写入要访问的单元的地址，然后就可以从数据端口71h中取得指定单元中的数据。  
例如，取当前小时的代码如下：
```x86asm
mov al,4
out 70h,al
in al,71h
```

### 关于关机和重启
- 写0x2001进端口0x1004可以使电脑关机；
- 写0xfe进端口0x64可以使电脑重启。
例如：
```c
// kernel.c
void Shutdown()
{
	Port_out_16(0x1004, 0x2001);
}

// 
```

```x86asm
; stdlib.asm

;funcname : _Port_out_16
;功能：		输入16位数据进16位端口
;入口参数： 栈
;出口参数： 无
;说明：     void Port_out_16(int port, int value) port和value 16位数据
;注意：     只由C调用，返回32位地址
_Port_out_16:
    push bp
    mov bp,sp
	push dx
	push ax
		mov dx, word[bp + 6]		; port	
        mov	ax, word[bp + 10]		; value	
		out	dx, ax
		nop							; 一点延迟
		nop
	pop ax
	pop dx
	pop bp
	retf
```